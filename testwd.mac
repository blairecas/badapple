	.title	TESTWD
	.enabl	LC

C_SCRWID  = 50
C_SCRSIZE = 240.*C_SCRWID

C_ELINE   = 120000
C_VADDR_O = C_ELINE + C_SCRWID
C_VADDR_E = C_VADDR_O + C_SCRSIZE

C_VTAB_O  = 73000
C_VTAB_E  = 75400

C_HEADS   = 16.
C_SECTORS = 63.

	.asect
	.=0

Start:	; boot marker and skip space (!) used by wd resident
	nop
	br	St200

	.=200
St200:	; start PPU code
	mtps	#200
	mov	#1000, SP
	call	PPSen				; exec allocate
	movb	#20, PPCmd			; 20 - write
	mov 	#PpuStart, PPAcp
	call	PPSen
	movb	#30, PPCmd			; 30 - run
	call	PPSen
	; and that's all for CPU
	br	.

PPmsg:	.word	PPArr				; beginning of array addr
        .word	177777
PPArr:	.byte	0				; 23334 return value (0 - OK)
PPCmd:	.byte	1				; 23335 command
PPDev:	.word	32				; 23336 device type (32-ppu mem)
PPApp:	.word	0				; 23340 argument(s) (PPU addr for mem operations)
PPAcp:	.word	BootEnd-PpuStart/2		; 23342 CPU addr (length in words for mem allocate)
PPLen:	.word	BootEnd-PpuStart/2		; 23344 length in words

; send command to PPU
PPSen:	mov	#PPMsg, R2
	mov	#5, R3
	br	20$
10$:	movb	(R2)+, @#176676
20$:	tstb	@#176674
	bpl	20$
	sob	R3, 10$
	return

; //////////////////////////////////////////////////////////////////////////////
; // PPU boot code
; //////////////////////////////////////////////////////////////////////////////

PpuStart:
	mtps	#200
	bic	#1, @#177054			; allow 100000-117777 window
	bis	#^B11100000, @#177054		; allow RAM on addrs 120000+
	; read sectors from 3rd ... our main code is there
	mov	#110016, R5			; 110016 data port addr
	mov	#110014, R4			; 110014 error code 
	mov	#^C<End-1000/1000+1>, -(R4)	; 110012 read sectors count
	mov	#^C3, -(R4)			; 110010 sector #3
	mov	#^C0, -(R4)			; 110006 cylinder # low byte
	mov	#^C0, -(R4)			; 110004 cylinder # high byte
	mov	#^C240, -(R4)			; 110002 head # (1010xxxx)	
	mov	#^C40, -(R4)			; 110000 command 0x20 - read sectors
	mov	#1000, R0			; where to read
	mov	#End-1000/2, R3			; length in words
10$:	bit	#^B1000, (R4)			; test command port
	bne	10$				; not ready
	mov	(R5), (R0)+			; get data
	sob	R3, 10$
	; jump to main code
	mov	#1000, SP
	jmp	(SP)
BootEnd:

	.if LT 1000-.
	.error first block addr limit exceeded
	.endc

; //////////////////////////////////////////////////////////////////////////////
; // PPU main code
; //////////////////////////////////////////////////////////////////////////////

	.asect
	.=1000

	; clear screen
	call	ClearScreen
	; clear high addrs
	mov	#End, R0
	mov	#100000-End/2, R1
	clr	(R0)+
	sob	R1, .-2
	; clear low addrs
	clr	R0
	mov	#2, (R0)+
	clr	(R0)+
	mov	#500-4/4, R3
10$:	clr	(R0)+
	mov	#200, (R0)+
	sob	R3, 10$
	mov	#1000-500/2, R3
	clr	(R0)+
	sob	R3, .-2
	; setup screens
	mov	#C_VTAB_O, R0
	mov	#C_VADDR_O, R1
	call	SetVLines
	mov	#C_VTAB_E, R0
	mov	#C_VADDR_E, R1
	call	SetVLines			; returns R0 - 'addr' for @#272
	clr	@#270
	mov	R0, @#272

	; vsync, keyboard, lpt
	mov	#VsyInt, @#100	
	bic	#^B0100000000, @#177054		; allow vsync in PPU
	mov	#KeyInt,  @#300
	clr	@#302				; (!) need for reentry into key int
	bis	#100, @#177700			; allow keyboard int
	mov	#177, @#177103			; all LPT ports to output

	; all is set then, go
	mtps	#0

; rendering video from start
Render:	call	ClearScreen

	; setup first track reading
	mov	#1, CurTrack			; 4 low bits is head #
	clr	@#77776				; addr used for 'end of video' mark
	mov	#110016, R5			; 110016 data port addr
	mov	#110014, R4			; 110014 error addr
	mov	#^C<C_SECTORS>, -(R4)		; 110012 sectors count to read
	mov	#^C1, -(R4)			; 110010 sector #1
	mov	#^C0, -(R4)			; 110006 cylinder #0 low byte
	mov	#^C0, -(R4)			; 110004 cylinder #0 high byte
	mov	#^C241, -(R4)			; 110002 head #1
	mov	#^C40, -(R4)			; 110000 command 0x20 read sectors
	call	WaitVsync

	; check for new covox on 177372
	mov	@#4, -(SP)
	mov	#PpInt4, @#4
	mov	#177372, R3			; new covox port
	clr	R0
	mov	#^x80, (R3)
	tst	R0
	beq	10$
	mov	#177100, R3			; audio port - LPT A
10$:	mov	(SP)+, @#4

	; R3 - audio port
	; R4 - IDE control port
	; R5 - IDE data port

; tracks reading cycle
;
Track:	; sectors reading
	mov	#C_SECTORS-1, R1		; 44T
Sector:	bit	#^B1000, (R4)			; 68T
	bne	.-4				; 20T
	mov	#17., R2			; 44T
10$:	mov	(R5), (R3)			; > 52T	- audio
	mov	(R5), @(R5)			; > 92T	+ video
	mov	(R5), @(R5)			; > 92T	+ video
	mov	(R5), (R3)			; > 52T		timings for IDE/audio port is less than RAM (8T each read/write)
	mov	(R5), @(R5)			; > 92T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), @(R5)			; > 92T
	sob	R2, 10$				; 40T
	mov	(R5), (R3)			; > 52T
	sob	R1, Sector			; 40T		
	; read last sector (not fully)
	bit	#^B1000, (R4)			; 68T
	bne	.-4				; 20T
	mov	#16., R2			; 44T
20$:	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	(R5), @(R5)			; > 92T
	sob	R2, 20$				; 40T
	; check for the end of video
	tst	@#77776				; 64T
	bne	Render				; 20T
	; (!) still have 16 words to read
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	; advance track (and read rest of last sector)
	inc	CurTrack			; 80T
	mov	#110014, R4			; 44T	110014 error data
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	#^C<C_SECTORS>, -(R4)		; 68T	110012 read sectors count
	mov	#^C1, -(R4)			; 68T	110010 sector #1
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	mov	CurTrack, R0			; 64T	
	mov	(R5), (R3)			; > 52T
	asr	R0				; 20T
	asr	R0				; 20T
	asr	R0				; 20T
	asr	R0				; 20T
	com	R0				; 20T
	mov	R0, -(R4)			; 44T	110006 cylinder low byte
	mov	(R5), (R3)			; > 52T
	mov	(R5), @(R5)			; > 92T
	swab	R0				; 20T
	mov	R0, -(R4)			; 44T	110004 cylinder high byte
	mov	(R5), (R3)			; > 52T
	mov	CurTrack, R0			; 64T
	bic	#^B1111111111110000, R0		; 44T
	mov	(R5), (R3)			; > 52T
	bis	#^B0000000010100000, R0		; 44T
	com	R0				; 20T
	mov	R0, -(R4)			; 44T	110002 head # (1010xxxx)
	mov	(R5), (R3)			; > 52T
	mov	#^C40, -(R4)			; 68T	110000 command 0x20 - read sectors
	jmp	Track				; 52T

; //////////////////////////////////////////////////////////////////////////////
; // Data, utils
; //////////////////////////////////////////////////////////////////////////////

CurTrack:	.word	0

; int 4 for testing registers
PpInt4:	inc	R0
	rti

; vsync interrupt
VsyInt:	inc	(PC)+
VsyCnt:	.word	0
	rti

; keyboard interrupt - pause/continue
KeyInt:	tstb	@#177702
	bmi	99$
	com	#000000
	beq	90$
	br	.
90$:	add	#4, SP
99$:	rti

; wait for #2 vsync (1/25)
WaitVsync:
	cmp	VsyCnt, #2
	blo	WaitVsync
	clr	VsyCnt
	return

; clear all planes
ClearScreen:
	mov	#177010, R4
	mov	#177012, R2
	mov	#177014, R5
	mov	#481.*C_SCRWID, R3
	mov	#C_ELINE, (R4)
10$:	clr	(R5)
	clr	(R2)
	inc	(R4)
	sob	R3, 10$
	return

; setup vlines table
; R0 - addr for it, R1 - vaddr
SetVLines:
	bic	#7, R0				; R0 - line table start addr
	mov	R0, -(SP)			; save it
	bis	#6, (SP)			; +6 means first line descriptor have color
	mov	#^B1111100011111000, (R0)+ 	; YRGB YRGB YRGB YRGB for colors 1st part
	mov	#^B1111100011111000, (R0)+	; YRGB YRGB YRGB YRGB for colors 2nd part
	clr	(R0)+				; vaddr not used for first 18 lines
	mov	R0, (R0)
	add	#2, (R0)
	bis	#2, (R0)+			; +2 means next line is scale&cursor
	mov	#^B0000000000010000, (R0)+	; black colored graph cursor
	mov	#^B0000000000010111, (R0)+	; max luminance (xxxDDxBGR, DD: 00-640, 01-320, 10-160, 11-80)
	clr	(R0)+				; vaddr still not needed
	mov	R0, (R0)
	add	#2, (R0)+			; +0 means next line is 2-word descriptor
	; 16.+24. empty lines
	mov	#16.+24., R3
10$:	mov	#C_ELINE, (R0)+			; empty line addr
	mov	R0, (R0)
	add	#2, (R0)+
	sob	R3, 10$
	; 240. main lines
	mov	#240., R3
20$:	mov	R1, (R0)+			; put vaddr
	mov	R0, (R0)			; put next element addr
	add	#2, (R0)+
	add	#C_SCRWID, R1			; advance vaddr
	sob	R3, 20$
	; 24. footer empty lines
	mov	#24., R3
30$:	mov	#C_ELINE, (R0)+
	mov	R0, (R0)
	add	#2, (R0)+
	sob	R3, 30$
	; return addr to lines table in R0
	mov	(SP)+, R0
	return

; fatal error
Error:	mtps	#200
	br	.

; type number and advance 'cursor'
TypeN:	mov	PC, R1
	add	#MsgNum-., R1
	call	PutOctal
	mov	PC, R0
	add	#MsgNum-., R0
	mov	CurVaddr, R1
	call	PpuPriStr
	add	#8., CurVaddr
	inc	CurCol
	cmp	CurCol, #10.
	bne	99$
	clr	CurCol
	add	#10.*C_SCRWID, CurVaddr
	inc	CurRow	
99$:	return

CurVaddr:	.word	0
CurCol:		.word	0
CurRow:		.word	0
MsgNum:		.asciz	"000000  "
		.even

; put octal number in R0 to (R1)+
PutOctal:
	mov	R2, -(SP)
	mov	R3, -(SP)
	mov	#6, R3
	clr	R2
	br	20$
10$:	clr	R2
	rol	R0
	rol	R2
	rol	R0
	rol	R2
20$:	rol	R0
	rol	R2
	add	#'0, R2
	movb	R2, (R1)+
	sob	R3, 10$
	mov	(SP)+, R3
	mov	(SP)+, R2
	return

C_FONT_ADDR	= 117430
C_FONT_DY	= 11.

; 117430 - addr of 0x00 character in ROM, font is 11. bytes per character, KOI8R
; R0 - string addr, R1 - vaddr
PpuPriStr:
	mov	R2, -(SP)
	mov	R4, -(SP)
	mov	R5, -(SP)
	mov	#177010, R4
	mov	#177014, R5
	mov	R1, (R4)
	mov	#C_SCRWID, R2
10$:	movb	(R0)+, R1
	beq	20$
	bic	#^B1111111100000000, R1
	mul	#C_FONT_DY, R1
	add	#C_FONT_ADDR, R1
	.rept	C_FONT_DY
	movb	(R1)+, (R5)
	add	R2, (R4)
	.endr
	sub	#C_FONT_DY*C_SCRWID-1, (R4)
	br	10$
20$:	mov	(R4), R1
	mov	(SP)+, R5
	mov	(SP)+, R4
	mov	(SP)+, R2
	return

End:
	.end	Start
